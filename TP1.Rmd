---
title: "TP1"
author: "GroupeB"
date: "`r Sys.Date()`"
output: html_document
---

## 1. Méthodologie : 

### 1. A propos des donnees

####  1.1 importation et source des données (À propos de l'auteur) ;

Dans le cadre du developpement de Copilot for Security Guided Response (CGR) la compagnie Microsoft a mis sur pied la base de données GUIDE qui est la plus large collection publique d'incidents réels de sécurité. Selon l'article AI-Driven Guided Response for Security Operation Centers with Microsoft Copilot for Security de Scott Freitas, Jovan Kalajdjieski, Amir Gharib, Robert McCann cette base de données aidera essentiellement à:  
- l’enquête, en fournissant un contexte historique essentiel en identifiant des incidents similaires ;
- effectuer un triage pour déterminer la nature de l’incident -- s’il s’agit d’un vrai positif(TP), d’un faux positif(FP) ou d’un positif bénin(BP) ; 
- l’assainissement, en recommandant des mesures de confinement adaptées.
Cette base de données est accessible en libre téléchargement via kagle(https://www.kaggle.com/datasets/Microsoft/microsoft-security-incident-prediction?select=GUIDE_Train.csv).

  
####  1.2 Description des variables ;
  
  Le jeu de données contient 1 048 573 observations et 46 variables.
Les variables sont réparties en 31 numériques et 15 catégorielles. 
L’objectif de cette base est de détecter des anomalies et prédire des attaques informatiques en fonctions de ces variables.


```{r}
df<- read.csv("data_subset.csv")
nrow(df)
ncol(df)
```

```{r}
#df<- read.csv("../data/GUIDE_Train.csv")

#Comptons le nombre de valeurs numériques

nombre_valeurs_numeriques <- sum(sapply(df, is.numeric))
print(nombre_valeurs_numeriques)
```

```{r}
#Comptons le nombre de valeurs catégorielles

nombre_valeurs_categorielles <- sum(sapply(df, is.factor)) + sum(sapply(df, is.character))
print(nombre_valeurs_categorielles)
```

###Variables cibles

Ces variables vont nous aider pour identifier les menaces et classifier les incidents

-IncidentGrade : La gravité de l'incident.

-MitreTechniques : Les techniques d'attaque basées sur la matrice MITRE ATT&CK. (A exclure trop de données absentes) 
-AlertTitle : Titre de l’alerte  cyberattaque.
-ThreatFamily : Famille de la menace détectée (A exclure trop de données absentes)
-ActionGranular : Actions détaillées de l'incident.

###Variables explicatives

Ces variables vont être utilisées pour prédire les anomalies et détecter des attaques

-Sha256 : Hash du fichier analysé
-Timestamp : La date et heure de l’incident.
-IpAddress : Adresse IP impliquée.
-DeviceId : Identifiant de l’appareil impacté.
-RegistryValueData : La valeur du registre Windows modifiée.
-FileName : Nom du fichier impacté.
-FolderPath : Chemin du fichier dans le système.
-ApplicationId : Identifiant unique de l’application impliquée.
-OSVersion : Version du système d’exploitation.
-Category : Catégorie de l’incident.
-EntityType : Type d’entité affectée( Ex:fichier).
-EvidenceRole : Rôle et la preuve évidente de l’incident.
-ApplicationName : Nom de l’application impliquée dans l’incident.
-OSFamily : Famille du système d’exploitation (ex : "Windows").
-ActionGrouped : L'impact des actions regroupées liées à l’incident.
-SuspicionLeve: Le niveau de suspicion attribué à l'incident détecté
-Usage:le mode d'utilisation du système

  
####  1.3 calcul des statistiques 
```{r importation-du-dataset-de travail}
df<- read.csv("data_subset.csv")
summary(df)
```
  
####  1.4 gestion des valeurs manquantes ;
  
  
## 2. Visualisations : 

 
###  2.1 Les histogrammes pour les variables catégorielles ;
```{r}
library(ggplot2)
ggplot(data=df, mapping=aes(x=Id, fill=IncidentGrade)) +#y=after_stat(density)),
  geom_histogram()+
  ggtitle("Représentation des IncidentGrade pour chacun des Id")
  theme_minimal()
  
ggplot(data=df, mapping=aes(x=Id, color=IncidentGrade)) +#y=after_stat(density)),
  geom_freqpoly()+
  ggtitle("Représentation des IncidentGrade pour chacun des Id")
  theme_minimal()

ggplot(data=df, mapping=aes(y=Category, fill=IncidentGrade)) +#y=after_stat(density)),
  geom_bar()+
  ggtitle("Répartition des IndentGrade pour chacune des catégories") + 
  theme(
    legend.position = "top",
  )+
  scale_x_discrete()+
  theme_minimal()



```
  2.2 Les diagrammes en boites pour les variables numériques ;
  
```{r}
library(ggplot2)
ggplot(data=df, mapping=aes(x=IncidentGrade,y=count(x))) +#y=after_stat(density)),
  geom_boxplot()+
  ggtitle("Représentation des IncidentGrade")
  theme_minimal()
```

```{r}
#Classification des incidents en fonction du grade dans les différentes entreprises
ggplot(df, aes(x=OrgId, y=IncidentId, color=IncidentGrade)) +
  geom_jitter(alpha=0.3)+
  ggtitle('Classification des incidents en fonction du grade dans les différentes entreprises')+
  theme_minimal()+
  theme(
    legend.position = "top",
    axis.line = element_line(linewidth = 0.75)
  )+
  scale_x_log10() +
  scale_y_log10() 

#Classification des incidents en fonction du grade dans les différentes entreprises
ggplot(df, aes(x=OrgId, y=IncidentId, color=IncidentGrade)) +
  geom_jitter(alpha=0.3)+
  ggtitle('Classification des incidents en fonction du grade dans les différentes entreprises')+
  theme_minimal()+
  theme(
    legend.position = "right",
    axis.line.x  = element_line(linewidth = 0.75)
  )+
  scale_x_log10() +
  scale_y_log10() +
  facet_wrap(~IncidentGrade,nrow=3)+
  theme(strip.background = element_blank())#+
  #title("Classification des incidents en fonction du grade dans les différentes entreprises")
  
  
```
  Nous remarquons l'absence de FP pour les organisations dont le OrgId est inférieur ou égal à 5.
  

  
  
  2.3 gestion des valeurs abérantes ;
  
  
## 3. Regression logistique


  

```{r library, include=FALSE}
library("tidyverse")
library("dplyr")
```


On charge les fichiers necessaires

```{r importation-outliers}
source("outliers.R")
#file.exists("outliers.R")
```

```{r plot_distribution}
source("plot_distribution.R")
#file.exists("plot_distribution.R")
```




#```{r importation-du-dataset}
#df<- read.csv("../data/GUIDE_Train.csv")
#head(df)
#View(df)
#```
Afin de faciliter notre manipulation des données nous avons réécrit la base de donnée, cette fois en selectionnant
uniquement les 25000 premieres lignes. (Le code est commanté expressement, pour ne pas etre réexécuté)


#```{r ecriture-de-la-base-donnee}
#library(readr)
#df_subset <- df[1:25000, ]
#write_csv(df_subset, "data_subset.csv")
#```


```{r importation-du-dataset-de travail}
df<- read.csv("data_subset.csv")
head(df)
#View(df)
```




```{r les-variables}
colnames(df)
```

Le jeu de donnees a **`r ncol(df)`** variables et **`r nrow(df)`**

```{r types-des-variables}
glimpse(df)
View(df)
```
```{r statistiques}
summary(df)
```


```{r recherche valeurs manquantes}
#avant cela if faudra inserrer na pour toutes les valeurs manquantes.


#recherche de valeur manquante
colSums(is.na(df))

#traitement des valeurs manquantes dans la colonne EmailClusterId
#nombre de valeurs manquantes dans la colonne
nb_valeurs_manquant_EmailClusterId = sum(is.na(df[,"EmailClusterId"]))
ratio = nb_valeurs_manquant_EmailClusterId/nrow(df)
ratio
df_clean = df[,colSums(is.na(df))==0]

```
On a `r ratio` valeur manquantes dans la colonne EmailClusterId. Nous décidons donc de la supprimer.

### Visualisation:
```{r visualisation}
#Les histogrammes de variables quantitatives 
#Les organisations enregistrés 
hist(df$OrgId, breaks=15,col="red", main="Histogramme des organisations",
     xlab="Les organisations"
     )

#Les incidents et les alertes 
par(mfrow=c(2,2))

hist(df$IncidentId, breaks=15,col="red",main="Histogramme des incidents", 
     xlab="Les incidents"
     )

hist(df$AlertId,breaks=15,col="red",main="Histogramme des alertes",
     xlab="Les alertes"
     )
#Les boxplots 

```
